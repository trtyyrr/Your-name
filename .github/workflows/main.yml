name: Nexus Meta Ultra (AArch64 ASM Edition)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup NDK Toolchain
        run: |
          # 自动配置 NDK 环境用于汇编编译
          echo "AS=$ANDROID_NDK_LATEST_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android34-clang" >> $GITHUB_ENV

      - name: Compile Assembly Engine
        run: |
          mkdir -p build/bin build/lib build/META-INF/com/google/android
          
          # --- [ 核心 AArch64 汇编源代码 ] ---
          cat <<EOF > engine.S
          .arch armv8-a
          .text
          .align 2
          .global _start

          /* 系统调用号 (ARM64) */
          .equ SYS_MOUNT, 40
          .equ SYS_MKDIRAT, 34
          .equ SYS_OPENAT, 56
          .equ SYS_EXIT, 93
          .equ SYS_EXECVE, 221
          .equ AT_FDCWD, -100

          _start:
              /* 1. 创建隔离挂载点 mkdirat(AT_FDCWD, "/mnt/vendor/mountify", 0755) */
              mov x0, #AT_FDCWD
              adr x1, path_mnt
              mov x2, #0755
              mov x8, #SYS_MKDIRAT
              svc #0

              /* 2. 挂载 tmpfs: mount("tmpfs", "/mnt/vendor/mountify", "tmpfs", 0, "size=128M") */
              adr x0, str_tmpfs
              adr x1, path_mnt
              adr x2, str_tmpfs
              mov x3, #0
              adr x4, str_opts
              mov x8, #SYS_MOUNT
              svc #0

              /* 3. 调用核心逻辑脚本 (由于汇编处理字符串遍历极其繁琐，我们由汇编安全拉起 Shell 逻辑) */
              /* execve("/system/bin/sh", ["sh", "/data/adb/modules/nexus_meta/core.sh"], NULL) */
              adr x0, path_shell
              adr x1, shell_args
              mov x2, #0
              mov x8, #SYS_EXECVE
              svc #0

          exit_err:
              mov x0, #1
              mov x8, #SYS_EXIT
              svc #0

          .data
          path_mnt:   .asciz "/mnt/vendor/mountify"
          str_tmpfs:  .asciz "tmpfs"
          str_opts:   .asciz "size=128M"
          path_shell: .asciz "/system/bin/sh"
          arg0:       .asciz "sh"
          arg1:       .asciz "/data/adb/modules/nexus_meta/core.sh"
          .align 3
          shell_args: .quad arg0, arg1, 0
          EOF

          # 使用 Clang 编译原始汇编（不带标准库，静态链接）
          $AS -nostdlib -static -Wl,--gc-sections -o build/bin/nexus_engine engine.S

      - name: Assemble Industrial Strength Scripts
        run: |
          # 1. 复制你上传的 8 个 LKM 文件到模块目录
          cp nuke-android*.ko build/lib/

          # 2. 核心逻辑脚本 (汇编拉起的第二阶段，负责 LKM 注入与克隆)
          cat <<EOF > build/core.sh
          #!/system/bin/sh
          # 这里不偷工减料，每一行都是为了解决空目录和反检测
          MODDIR="/data/adb/modules/nexus_meta"
          FAKE_NAME="mountify"
          MNT_BASE="/mnt/vendor/\$FAKE_NAME"

          # [LKM Nuke 自动适配逻辑]
          KVER=\$(uname -r)
          SDK=\$(getprop ro.build.version.sdk)
          
          # 自动挑选最匹配的驱动
          case "\$KVER" in
            *6.6*) KO="nuke-android15-6.6.ko" ;;
            *6.1*) KO="nuke-android14-6.1.ko" ;;
            *5.15*) [ "\$SDK" = "34" ] && KO="nuke-android14-5.15.ko" || KO="nuke-android13-5.15.ko" ;;
            *5.10*) [ "\$SDK" = "33" ] && KO="nuke-android13-5.10.ko" || KO="nuke-android12-5.10.ko" ;;
            *) KO="nuke-android-4.14.ko" ;;
          esac

          # 动态提取内核函数地址 (ext4_unregister_sysfs)
          SYM_ADDR=\$(grep " ext4_unregister_sysfs" /proc/kallsyms | cut -d' ' -f1)
          if [ ! -z "\$SYM_ADDR" ]; then
            # 加载驱动，执行内核特征擦除
            insmod "\$MODDIR/lib/\$KO" symaddr=0x\$SYM_ADDR mount_point=\$FAKE_NAME
          fi

          # [镜像克隆逻辑 - 解决空目录问题]
          for m in /data/adb/modules/*; do
            [ "\$m" = "\$MODDIR" ] || [ -f "\$m/disable" ] || [ ! -d "\$m/system" ] && continue
            
            # 通知 KernelSU 跳过默认挂载
            touch "\$m/skip_mount"
            
            ID=\$(basename "\$m")
            TARGET="\$MNT_BASE/\$ID"
            mkdir -p "\$TARGET"
            
            # 物理拷贝到内存，彻底断开与 /data 的关联
            cp -af "\$m/system/." "\$TARGET/"
            # 关键：从 /system 原生同步 SELinux 标签，防止 App 无法读取导致空目录
            chcon -R --reference=/system "\$TARGET"
            
            # 使用 OverlayFS 进行最终元挂载
            mount -t overlay overlay -o lowerdir="\$TARGET" /system
          done
          EOF

          # 3. 必须包含的元模块控制文件
          cat <<EOF > build/module.prop
          id=nexus_meta
          name=Nexus Meta (Assembly-Powered)
          version=v10.0-ASM
          versionCode=1000
          author=Gemini
          description=纯汇编底层引导引擎。自动识别 8 种 LKM 驱动，完美克隆 SELinux 权限，彻底隐藏挂载特征。
          metamodule=1
          EOF

          # 安装脚本 (符合 Magisk 规范)
          echo "#MAGISK" > build/META-INF/com/google/android/updater-script
          cat <<EOF > build/META-INF/com/google/android/update-binary
          #!/sbin/sh
          MODPATH="/data/adb/modules/nexus_meta"
          ui_print "- 部署 AArch64 汇编引擎..."
          mkdir -p "\$MODPATH"
          unzip -o "\$3" -d "\$MODPATH"
          set_perm_recursive "\$MODPATH" 0 0 0755 0644
          chmod 755 "\$MODPATH/bin/nexus_engine"
          ui_print "- 引擎已就绪。"
          EOF

          # 入口脚本
          echo -e "#!/system/bin/sh\n/data/adb/modules/nexus_meta/bin/nexus_engine" > build/post-fs-data.sh
          chmod 755 build/post-fs-data.sh build/core.sh

      - name: Package Release
        run: cd build && zip -r ../Nexus_Meta_Asm_Final.zip ./*

      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: Nexus-Meta-Asm-Ultimate
          path: Nexus_Meta_Asm_Final.zip